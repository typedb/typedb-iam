Demonstrator's guide:

1. Run `define-schema.tql`
2. Run `insert-data.tql`
3. Run example queries.

01-list-group-memberships
This example lists the user groups that Kevin Morrison is a member of.
There are six results, with three of them being inferred with one layer of inference.
This is a great example for showing the difference between having `infer` on and off as well as for showing some basic explanations.

02-list-group-members
This example lists the users that are members of the "engineer" user role.
Pearle Goodman has direct membership of the role (zero layers of inference).
Kevin Morrison is a member through membership of the "Engineering" business unit (one layer).
Douglas Schmidt is a member through membership of the "Core" business unit, which has membership of the "Engineering" business unit (two layers).
Genevieve Gallegos is a member through membership of the "Client" business unit, which has membership of the "Engineering" business unit (two layers).
This is a good example for showing the chaining property of rule inference as well as the type inference involved in the polymorphic `group-membership` relation.

03-check-permission
This example checks that a single permission exists: can Douglas Schmidt edit the readme file in the typedb studio source directory?
This is a really powerful example of rule chaining involving seven layers of inference and between three and five rules, but must be handled carefully.
There is a single result derived from a single set of base facts, but there are (2^4 * 7!) / (3! * 3!) = 2240 potential orderings for rule activations (I think).
This means that if everything inferred is explained, studio will go through all possible routes, so in order to demo this it is important to stay on one inference route.
The easiest way to do this is: explain each inherited permission only once, which generates the next inherited permission, until the direct permission is reached after five explanations.
This also generated inferred memberships, which can then afterwards be explored for even more depth if needed, or the demo can end there.
Because a lot of concepts are generated by this demo, and because it's important to keep track of what has been explained, concepts should be pinned by manually moving them.
The full set of base facts as to why this permission exists is:
Douglas Schmidt has membership of the business unit "Core", which has membership of the business unit "Engineering", which has membership of the user role "engineer".
The file "README.md" has membership of the directory "src", which has membership of the directory "typedb-studio", which has membership of the directory "root/engineering".
The operation "edit file" has membership of the operation set "write file".
The user role "engineer" has permission to the access that exists between the operation set "write file" and the directory "root/engineering".

04-list-subject-permissions
This example lists all of Douglas Schmidt's permissions.
This is intended as a follow up to example 03, and is not intended to be fully explained, instead making the point:
If the previous example took seven layers of inference, imagine all of the inference involved in generating all 67 of Douglas' permissions.

05-list-segregation-violations
This example doesn't work at the moment due to inserting a `segregation-policy` causing the reasoner to hang for almost all queries.
